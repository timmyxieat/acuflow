# 1.02b Schema Clarifications

**Date:** December 10, 2025
**Status:** Addressing user feedback before schema changes

---

## 1. Practitioner Notes vs Patient Notes - Clarification

These serve **different purposes**:

### practitionerNotes (on Appointment)
- **Per-visit, clinical, private**
- "Remember to follow up on job stress next visit"
- "Patient seemed distracted today - check in on home situation"
- Only visible to the practitioner who wrote it
- Tied to a specific appointment
- **Use case:** Clinical memory jogger for next time you see this note

### PatientNote (CRM table)
- **Ongoing, rapport-building, shared**
- "Visiting daughter in Arizona for Thanksgiving"
- "Loves hiking, just did Yosemite"
- Visible to all practitioners in the clinic
- Lives on the patient, grows over time
- **Use case:** Relationship building across all visits

### Do we need both?

**Yes, I think so.** They serve different needs:

| Aspect | practitionerNotes | PatientNote |
|--------|-------------------|-------------|
| Scope | Single appointment | Patient lifetime |
| Visibility | Private to author | Shared in clinic |
| Purpose | Clinical reminder | Rapport building |
| Location | On Appointment | On Patient |

**However**, if you feel this is too much, we could:
- Remove `practitionerNotes` from Appointment
- Use PatientNote with a `CLINICAL_REMINDER` category that's visit-linked and private

**Question for you:** Keep both, or consolidate into PatientNote with categories?

---

## 2. NoteCategory Enum - Rethinking

You're right, the categories are confusing. Let me rethink:

### Original (Confusing)
```
PERSONAL            // Life stuff
PREFERENCE          // Scheduling preferences
CLINICAL_REMINDER   // Clinical notes
```

### Revised Approach: Just use tags or no categories

**Option A: Remove categories entirely**
```prisma
model PatientNote {
  id          String
  patientId   String
  content     String
  isPinned    Boolean @default(false)
  isPrivate   Boolean @default(false)  // Only author sees it
  createdAt   DateTime
  createdBy   String
}
```

- Pinned = important, always show at top
- Private = only you see it (like practitionerNotes was)
- Everything else is just chronological notes

**Option B: Simple binary - Personal vs Clinical**
```prisma
enum NoteType {
  RAPPORT      // Life stuff, rapport building
  CLINICAL     // Clinical reminders, preferences
}
```

**My recommendation:** Option A (no categories, just isPinned and isPrivate). Simpler, practitioners don't have to think about categorizing.

---

## 3. Medical Profile History - Detailed Flow

You asked: How does adding MedicalProfileHistory update Patient.medicalProfile?

### The Flow (Step by Step)

**Starting state:**
```
Patient {
  id: "patient_123"
  medicalProfile: {
    "medications": {
      "current": [
        { "name": "Lisinopril", "dose": "10mg" }
      ],
      "significantPast": [],
      "lastUpdated": "2024-01-15"
    }
  }
}

MedicalProfileHistory: [] (empty)
```

**Action: Practitioner edits medications during Visit #10**

1. Practitioner opens Medications section
2. Adds "Metformin 500mg"
3. Removes "Lisinopril 10mg" (patient switched)
4. Clicks Save

**What happens on Save:**

```javascript
// 1. Capture the BEFORE state
const previousValue = patient.medicalProfile.medications;
// { current: [{ name: "Lisinopril", dose: "10mg" }], ... }

// 2. Apply the changes to create NEW state
const newValue = {
  current: [
    { name: "Metformin", dose: "500mg", frequency: "2x daily" }
  ],
  significantPast: [],
  lastUpdated: "2024-03-15",
  lastUpdatedVisitId: "visit_10"
};

// 3. UPDATE Patient.medicalProfile (the source of truth for CURRENT state)
await prisma.patient.update({
  where: { id: "patient_123" },
  data: {
    medicalProfile: {
      ...patient.medicalProfile,
      medications: newValue
    }
  }
});

// 4. CREATE MedicalProfileHistory record (for audit trail)
await prisma.medicalProfileHistory.create({
  data: {
    patientId: "patient_123",
    visitId: "visit_10",  // Links to this visit
    section: "medications",
    changeType: "modified",
    changeDescription: "Added Metformin 500mg, Removed Lisinopril 10mg",
    previousValue: previousValue,
    newValue: newValue,
    changedBy: "practitioner_456",
    changedAt: new Date()
  }
});
```

**Ending state:**
```
Patient {
  id: "patient_123"
  medicalProfile: {
    "medications": {
      "current": [
        { "name": "Metformin", "dose": "500mg", "frequency": "2x daily" }
      ],
      "significantPast": [],
      "lastUpdated": "2024-03-15",
      "lastUpdatedVisitId": "visit_10"
    }
  }
}

MedicalProfileHistory: [
  {
    id: "history_001",
    patientId: "patient_123",
    visitId: "visit_10",
    section: "medications",
    changeType: "modified",
    changeDescription: "Added Metformin 500mg, Removed Lisinopril 10mg",
    previousValue: { current: [{ name: "Lisinopril", dose: "10mg" }], ... },
    newValue: { current: [{ name: "Metformin", ... }], ... },
    changedBy: "practitioner_456",
    changedAt: "2024-03-15T10:30:00Z"
  }
]
```

### Key Points

1. **Patient.medicalProfile** = Current state (what you read during appointment)
2. **MedicalProfileHistory** = Audit trail (when/what/who changed)
3. **Both update simultaneously** on save
4. **changeDescription** = Human-readable summary auto-generated

### UX: Practitioner Experience

```
┌──────────────────────────────────────────────────────────────────┐
│  MEDICATIONS                                    [Edit]           │
│                                                                   │
│  Current:                                                         │
│  • Metformin 500mg 2x daily                                       │
│                                                                   │
│  Last updated: Mar 15, 2024 (Visit #10)                          │
│                                                                   │
│  [View History]  ← Click to see MedicalProfileHistory             │
└──────────────────────────────────────────────────────────────────┘
```

Clicking "Edit" opens modal, practitioner makes changes, saves.
History is automatic - practitioner never "manages" it.

---

## 4. Gender-Based Point Sides

Good catch! Some protocols use gender-based logic.

### Updated PointSide Enum

```prisma
enum PointSide {
  // Fixed sides
  BILATERAL
  LEFT
  RIGHT
  CENTER

  // Dynamic - based on affected side
  CONTRALATERAL    // Opposite of affected side
  IPSILATERAL      // Same as affected side

  // Dynamic - based on patient gender
  GENDER_MALE_SIDE   // Left for male, Right for female
  GENDER_FEMALE_SIDE // Right for female, Left for male
}
```

**Wait** - this naming is confusing. Let me think...

Actually, the convention is:
- **Male = Left side**
- **Female = Right side**

So we could just have:

```prisma
enum PointSide {
  // Fixed
  BILATERAL
  LEFT
  RIGHT
  CENTER

  // Dynamic - pain location
  CONTRALATERAL
  IPSILATERAL

  // Dynamic - gender
  GENDER_BASED   // Male→Left, Female→Right
}
```

### Resolution Logic

When applying protocol to a **female patient** with **right shoulder pain**:

| Point | ProtocolPoint.side | Resolved |
|-------|-------------------|----------|
| LI4 | CONTRALATERAL | LEFT |
| GB34 | IPSILATERAL | RIGHT |
| KD3 | GENDER_BASED | RIGHT (female) |
| SP6 | GENDER_BASED | RIGHT (female) |
| DU20 | CENTER | CENTER |

For a **male patient** with same right shoulder pain:

| Point | ProtocolPoint.side | Resolved |
|-------|-------------------|----------|
| LI4 | CONTRALATERAL | LEFT |
| GB34 | IPSILATERAL | RIGHT |
| KD3 | GENDER_BASED | LEFT (male) |
| SP6 | GENDER_BASED | LEFT (male) |
| DU20 | CENTER | CENTER |

### Protocol Application UI

```
┌──────────────────────────────────────────────────────────────────┐
│  Apply: Kidney Tonification Protocol                              │
│                                                                   │
│  Patient: John Smith (Male)                                       │
│                                                                   │
│  This protocol has gender-based points.                           │
│  Male patients: Left side                                         │
│                                                                   │
│  Preview:                                                         │
│  KD3   → LEFT (gender-based)                                      │
│  KD7   → LEFT (gender-based)                                      │
│  SP6   → LEFT (gender-based)                                      │
│  RN4   → CENTER (fixed)                                           │
│                                                                   │
│  [Cancel]                              [Apply Protocol]           │
└──────────────────────────────────────────────────────────────────┘
```

---

## 5. Payment + Transaction Dates

You asked: If copay is Jan 15 and insurance payout is Jan 22, what date is on Payment?

### Answer: Payment.createdAt = when visit happened

```prisma
model Payment {
  id            String   @id
  appointmentId String   @unique
  amountDue     Decimal
  status        PaymentStatus

  createdAt     DateTime @default(now())  // When payment record created (visit day)
  updatedAt     DateTime @updatedAt       // When last modified

  transactions  PaymentTransaction[]
}

model PaymentTransaction {
  id            String   @id
  paymentId     String
  method        PaymentMethod
  amount        Decimal

  transactedAt  DateTime @default(now())  // When THIS transaction happened

  payment       Payment  @relation(...)
}
```

### Example Timeline

**Jan 15 - Visit day:**
```
Payment {
  id: "pay_001"
  appointmentId: "appt_123"
  amountDue: 150.00
  status: PARTIAL
  createdAt: "2024-01-15"  ← Visit day
}

PaymentTransaction {
  id: "txn_001"
  paymentId: "pay_001"
  method: CARD
  amount: 30.00
  transactedAt: "2024-01-15"  ← Copay day
}
```

**Jan 22 - Insurance pays:**
```
Payment {
  id: "pay_001"
  amountDue: 150.00
  status: PAID  ← Updated
  createdAt: "2024-01-15"  ← Still visit day
  updatedAt: "2024-01-22"  ← When we recorded insurance
}

PaymentTransaction {
  id: "txn_001"
  method: CARD
  amount: 30.00
  transactedAt: "2024-01-15"
}

PaymentTransaction {
  id: "txn_002"  ← NEW
  paymentId: "pay_001"
  method: INSURANCE_PAYOUT
  amount: 120.00
  transactedAt: "2024-01-22"  ← Insurance pay day
}
```

### Key Dates

| Field | Meaning |
|-------|---------|
| Payment.createdAt | When visit/appointment happened |
| Payment.updatedAt | Last time anything changed |
| Transaction.transactedAt | When that specific payment was made |

This way you can:
- Query "visits in January" → Payment.createdAt
- Query "money received in January" → Transaction.transactedAt
- See full payment history with exact dates

---

## 6. Default Technique - NONE vs EVEN

You said default should be NONE (no manipulation), not EVEN.

### Updated NeedlingTechnique Enum

```prisma
enum NeedlingTechnique {
  NONE        // No manipulation after insertion (most common)
  EVEN        // Neutral technique
  TONIFYING   // Strengthening
  REDUCING    // Draining
}
```

**Default:** `NONE`

### Shorthand for Entry

You mentioned using letters (E, R, T). Let's define:

| Letter | Technique |
|--------|-----------|
| (none) | NONE (default) |
| E | EVEN |
| T | TONIFYING |
| R | REDUCING |

**Example text entry:**
```
LI4 B, GB34 L T, ST36 B R, BL40 R
     ^      ^ ^       ^ ^      ^
     |      | |       | |      technique
     |      | |       | side
     |      | technique
     |      side
     side (no technique = NONE)
```

Parsed:
- LI4 BILATERAL NONE
- GB34 LEFT TONIFYING
- ST36 BILATERAL REDUCING
- BL40 RIGHT NONE

### Overall Treatment Side

You mentioned "overall side for treatment" - this could be a field on Visit or handled in UI:

```
Treatment side: [Bilateral ▼]

Points: LI4, GB34, ST36 (all use treatment side unless specified)
Exception: BL40 R (explicitly right)
```

**Question:** Do you want an explicit `treatmentSide` field on Visit, or handle this purely in UI during point entry?

---

## 7. VAS Score Display - Visual Distinction

You want to see the history with distinction between patient-entered vs practitioner-entered.

### Visual Approach

```
┌──────────────────────────────────────────────────────────────────┐
│  LOW BACK PAIN - VAS History                                      │
│                                                                   │
│  ●━━━━━●━━━━━○━━━━━○━━━━━●                                        │
│  7     4     5     7     3                                        │
│  │     │     │     │     │                                        │
│  Jan 15 Jan 18 Jan 20 Jan 22 Jan 29                              │
│  Visit  SMS    SMS    Visit  Visit                               │
│                                                                   │
│  ● = Practitioner recorded (at visit)                            │
│  ○ = Patient reported (SMS/intake)                               │
│                                                                   │
│  Trend: Improving (7 → 3)                                         │
│  Status: ACTIVE → Suggest: IMPROVING                             │
└──────────────────────────────────────────────────────────────────┘
```

- **Filled dots (●)** = Practitioner-recorded (during visit)
- **Open dots (○)** = Patient self-reported (SMS, intake form)
- Both count toward trend, but visual distinction shows source

### Is SMS Follow-up Too Heavy?

You asked if this is too much. Here's my take:

**For MVP/Basic tier:** Skip SMS follow-up. VAS only recorded at visits.
**For Premium tier:** Add SMS follow-up as a feature.

The schema should support it (MeasurementSource enum), but we don't have to build the SMS flow immediately.

```prisma
enum MeasurementSource {
  VISIT           // Practitioner recorded during visit
  PATIENT_INTAKE  // Patient filled pre-visit form
  SMS_FOLLOWUP    // Patient responded to SMS (premium)
  MANUAL          // Manually entered outside visit
}
```

This way the schema is ready, but SMS feature can come later.

---

## 8. Condition Status - More Automatic

You said: Status should be automatic, practitioner only marks RESOLVED.

### Revised Approach

```
Status auto-updates based on VAS trend:
- If VAS dropping → IMPROVING (auto)
- If VAS flat → STABLE (auto)
- If VAS rising → WORSENING (auto)
- If VAS near zero → Suggest RESOLVED (practitioner confirms)

Practitioner actions:
- Mark as RESOLVED (removes from active list)
- Override status if auto-suggestion is wrong
```

### UI

```
┌──────────────────────────────────────────────────────────────────┐
│  CONDITIONS                                                       │
│                                                                   │
│  Low back pain                          VAS: 7 → 3 (improving)   │
│  Status: IMPROVING (auto)                         [Mark Resolved] │
│                                                                   │
│  Tinnitus                               VAS: 5 → 5 (stable)      │
│  Status: STABLE (auto)                            [Mark Resolved] │
│                                                                   │
│  Neck tension                           VAS: 3 → 6 (worsening)   │
│  Status: WORSENING (auto)                         [Mark Resolved] │
└──────────────────────────────────────────────────────────────────┘
```

Only action needed: "Mark Resolved" when condition is gone.
Everything else is automatic based on data.

---

## 9. Recognition Patterns - Documentation Location

You asked where to document recognition patterns.

### Suggested File Structure

```
/docs
  /specs
    /recognition-patterns.md     ← NEW: All text recognition rules
    /data-flows.md               ← NEW: How data moves between tables
  /handoffs
    /1.01_initiation.md
  /output
    /1.02_schema_design_discussion.md
    /1.02b_schema_clarifications.md
```

### recognition-patterns.md Contents

```markdown
# Text Recognition Patterns

## Subjective Section

### Condition Matching
- Match against patient's existing PatientCondition.name
- Fuzzy matching: "LBP" → "Low back pain", "HA" → "Headache"

### VAS Score Patterns
- "7/10", "7 out of 10", "pain 7", "VAS 7", "pain level 7"
- Extract number, associate with preceding condition mention

## Plan Section

### Point Recognition
- Pattern: [MERIDIAN][NUMBER] [SIDE] [TECHNIQUE]
- Meridians: LU, LI, ST, SP, HT, SI, BL, KD, PC, SJ, GB, LV, RN, DU
- Sides: B (bilateral), L (left), R (right), C (center)
- Techniques: T (tonifying), R (reducing), E (even), (none) = NONE

### Protocol Triggers
- Pattern: /[protocol-name] [SIDE]
- Example: /four-gates B, /shoulder-pain R

## Objective Section

### Known Subsections
- Tongue:, Pulse:, BP:, HR:, Temp:, Weight:
- Pattern: [keyword]: [value until newline or next keyword]
```

---

## 10. Intake Forms - Pre-Visit & Re-evaluation

You mentioned:
- Initial intake form (before first visit)
- Re-evaluation form (before follow-up visits)
- SMS check-ins throughout week

### Schema Support

The current schema supports this:

```prisma
// Patient.medicalProfile stores current state
// Can be populated from intake form

// MedicalProfileHistory tracks when/how it was updated
// source could indicate: "INITIAL_INTAKE", "REEVALUATION_FORM", "VISIT"

model MedicalProfileHistory {
  // ...existing fields...
  source    ProfileUpdateSource?  // NEW
}

enum ProfileUpdateSource {
  INITIAL_INTAKE      // First-time patient form
  REEVALUATION_FORM   // Pre-visit update form
  VISIT_UPDATE        // Practitioner updated during visit
  PATIENT_PORTAL      // Patient updated via portal
}
```

### Flow

1. **New patient books** → Sent intake form link
2. **Patient fills form** → Patient.medicalProfile populated, MedicalProfileHistory created with source: INITIAL_INTAKE
3. **Follow-up visit booked** → Sent re-evaluation form
4. **Patient updates** → medicalProfile updated, history with source: REEVALUATION_FORM
5. **During visit** → Practitioner can edit, history with source: VISIT_UPDATE

---

## Questions Before Schema Changes

1. **PatientNote vs practitionerNotes:** Keep both, or consolidate into PatientNote with isPinned/isPrivate?

2. **NoteCategory:** Remove categories entirely (just isPinned + isPrivate), or use simple RAPPORT/CLINICAL?

3. **Gender-based sides:** Add `GENDER_BASED` to PointSide enum?

4. **Treatment side on Visit:** Add explicit `treatmentSide` field, or handle in UI only?

5. **SMS follow-up:** Include FollowUpRequest table now (schema ready, build later), or defer entirely?

6. **ProfileUpdateSource:** Add this enum to track where medical profile updates came from?

---

## Schema Changes - Final List

Pending your answers, here's what I'll implement:

### Confirmed
1. ✅ Remove `ProtocolSideType` enum from PointProtocol
2. ✅ Add `practitionerId` to TreatmentPackage
3. ✅ Add `restrictToPractitionerId` to PatientPackage
4. ✅ Replace Payment with Payment + PaymentTransaction
5. ✅ Add PaymentMethod and PaymentStatus enums
6. ✅ Add MedicalProfileHistory table
7. ✅ Add PatientNote table
8. ✅ Add `source` to ConditionMeasurement (MeasurementSource enum)
9. ✅ Change default NeedlingTechnique to NONE (add NONE to enum)
10. ✅ Keep cancellationReason (optional)
11. ✅ Keep practitionerNotes on Appointment (unless you say consolidate)

### Pending Your Answer
- Gender-based PointSide
- treatmentSide on Visit
- FollowUpRequest table
- ProfileUpdateSource enum
- NoteCategory approach
